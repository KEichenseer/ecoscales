---
title: "Space-time plots"
author: "Lyndon Estes"
date: "December 3, 2015"
output: 
  html_document:
    toc: yes
    number_sections: true
    toc_depth: 3
---

# Space versus time analysis
```{r, message = FALSE, warning=FALSE, results='hold'}
library(ecoscales)
library(readxl)
library(stringdist)
library(maptools)

p_root <- set_base_path("ecoscales")
p_dat <- full_path(p_root, "external/data/result")
p_calib <- full_path(p_root, "external/data/calibration")
# dat <- as.data.table(read_excel(full_path(p_dat, "merged.xlsx")))
dat <- as.data.table(read_excel(full_path(p_dat, "mergedf.xlsx")))
cal <- data.table(read_excel(fp(p_calib, "merged_calibrationff.xlsx")))

setnames(dat, "DOI/title", "DOI")
dat[, DOI := gsub("DOI:|doi:|DOI: |doi: |DOI ", "", DOI)]
dat[, DOI := gsub("\\s", "", DOI)]  # remove DOI and whitespace

dat <- dat[, names(dat)[1:20], with = FALSE]
```

`r length(unique(dat$DOI))` papers  main analysis

## Data prep
### Merge full and calibration datasets
```{r, message=FALSE, warning=FALSE, results='hide'}
dat2 <- copy(dat[, .(plot_res, n_sites, sampled_area, samp_duration,
                     t_btwn_samp, study_duration)])

rnms <- c("DOI", "feature", "observer", "plot_res", "n_sites", 
          "sampled_area", "t_btwn_samp", "study_duration")
calr <- cal[, rnms, with = FALSE]
for(j in names(calr)[c(2, 4:8)]) set(calr, j=j, value = as.numeric(calr[[j]]))

# select down to columns of interest
calr <- calr[feature != 99, lapply(.SD, mean), by = .(DOI, feature), 
             .SDcols = rnms[4:8]]
length(unique(calr$DOI)) + length(unique(dat$DOI))  # 148 papers providing dat

calr[, samp_duration := NA]
calr[, c("DOI", "feature") := NULL]
setcolorder(calr, names(calr)[c(1:3, 6, 4:5)])

datf <- rbind(cbind("dsrc" = 1, dat2), cbind("dsrc" = 2, calr))
```

### Adjustments/fixes
1. if `samp_duration != study_duration` and `t_btwn_samp == 0`, set `study_duration == samp_duration` (actually, no, in many cases there is a good reason to have to `study_duration != samp_duration` (see below))
2. Prior to scaling the data in log10 space, we need to make one adjustment. Time between samples has many 0 values because many observations are simply one-offs.  Set these to an arbitrarily large value which will represent clear separation on axis from high frequency studies. A function is defined here for this purpose, and will be applied after bootstrapping is done. 

```{r, message=FALSE, warning=FALSE, results='hide'}
# apply fixes (mostly to account for observer omissions)
# 1. if samp_duration != study_duration and t_btwn_samp == 0, set 
#    study_duration == samp_duration
names(datf)
datf[t_btwn_samp == 0 & (study_duration != samp_duration), ]  
dat[t_btwn_samp == 0 & (study_duration != samp_duration), c(1, 3, 8:13), with=F]  
# function to set t_btwn_samp to 365 * 100000 to indicate once-off studies 
# when t_btwn_samp == 0.  
to_infin_byond <- function(tbtwn) ifelse(tbtwn == 0, 365 * 10000, tbtwn)

```

## Analyses

### Resampling with uncertainties

Defined by the per variable CV based on uncertainty between observers. Here we are just going to use apply the variability to each variable for every observation (previous incarnation used uncertainty on just the variables listed as uncertain, with recalculation of dependent variables (`study_duration`, `sampled_area`) made after pertubation [see commit prior to second or third commit on 4 April for code]).

```{r, eval=FALSE}
p <- c(0.79, 0.99, 0.53, 1.22)  # from calibration.Rmd

# Function for bootstrapping with uncertainties
resamp_func <- function(dat, p, iter) {
  bout <- lapply(1:iter, function(x) {
    if((x / 100) %in% 1:100) print(x)
    if(length(p) < 4) stop("p must be length of 4", call. = FALSE)
    
    dnew <- copy(datf[, .(plot_res, sampled_area, t_btwn_samp, study_duration)])
    # modifiers
    modvec <- sapply(p, function(y) {
      mv <- runif(nrow(dnew), min = 1 - y, max = 1 + y)
      mv
    })

    for(j in 1:ncol(modvec)) set(dnew, j = j, value = dnew[[j]] * modvec[, j])
    dnew[plot_res <= 0, plot_res := 0.00000001]
    dnew[sampled_area <= 0, sampled_area := 0.00000001]
    dnew[study_duration <= 0, study_duration := 0.00000001]
    dnew[t_btwn_samp < 0, t_btwn_samp := 0.00000001]

    dnew[, t_btwn_samp := to_infin_byond(t_btwn_samp)]  # set high
    dnew
  })
  return(bout)
}

set.seed(1)
bootperturb <- resamp_func(datf, p = p, iter = 1000)  # 10% perturb
# bootperturb2 <- resamp_func(datf, p = p, iter = 1000)  # 10% perturb
# all(bootperturb[[200]]$plot_res == bootperturb2[[200]]$plot_res)
# rm(bootperturb2)

```

### Bootstrapping

Good old-fashioned bootstrapping with replacement, no perturbation of value
```{r, eval = FALSE}
# bootstrap
set.seed(1)
bootsamp <- lapply(1:1000, function(x) {
  if((x / 100) %in% 1:100) print(x)
  dnew <- copy(datf[, .(plot_res, sampled_area, t_btwn_samp, study_duration)])
  dnew <- dnew[sample(1:.N, size = .N, replace = TRUE), ]
  dnew[, t_btwn_samp := to_infin_byond(t_btwn_samp)]  # set high
  dnew
})

```

## Plots
### Scaling in log10 space
```{r, eval = FALSE}
i <- 0.0000001
j <- rep(0, 16)
for(k in 1:length(j)) {
  i <- i * 10
  j[k] <- i
}

# temporal scales
tdt <- data.table("scaleval" = j, "time" = j)
tdt[, tlog := log10(time)]

# labels for temporal axes
# return interval
tlab1 <- c(expression(paste(NULL<="second"^-1)), expression("minute"^-1),
           expression("hour"^-1), expression("day"^-1), 
           expression("week"^-1), expression("month"^-1),            
           expression("year"^-1), expression("decade"^-1),
           expression("century"^-1), 
           expression("millenium"^-1), "once-off")# expression(infinity))
taxis1 <- cbind.data.frame( 
  c(1 / (24 * 60 * 60), 1 / (24 * 60), 1 / 24, 1, 7, 30, 365, 365 * 10, 
    365 * 100, 365 * 1000, 365 * 10000))
taxis1 <- data.table(taxis1)
setnames(taxis1, names(taxis1), "days")
taxis1[, logdays := log10(days)]

tlab2 <- c(expression(NULL<="second"), "minute", "hour", "day", "week", "month",
           "year","decade", "century", "millenium", "10 KA")  
taxis2 <- cbind.data.frame(c(1 / (24 * 60 * 60), 1 / (24 * 60), 1 / 24, 1, 7, 30,
                             365, 365 * 10, 365 * 100, 365 * 1000, 365 * 10000))
taxis2 <- data.table(taxis2)
setnames(taxis2, names(taxis2), c("days"))
taxis2[, logdays := log10(days)]

# spatial
# plot(1:10, xlab = expression(paste("mm"^2)), xaxt = "n")
# axis(1, at = 1:8, labels = lab, las = 2)

# plot resolution
alab1 <- c(expression(paste(NULL<="0.01 cm"^2)), expression("0.1 cm"^2), 
           expression("1 cm"^2), expression("10 cm"^2),
           expression("100 cm"^2), expression("1000 cm"^2), 
           expression("1 m"^2), expression("10 m"^2),
           expression("100 m"^2), expression("1000 m"^2), 
           "1 ha", "10 ha", "100 ha", "1000 ha", 
           expression(paste(NULL>="10000 ha")))

aaxis1 <- cbind.data.frame(c(0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1,
                             1^2, 10, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8))
aaxis1 <- data.table(aaxis1)
setnames(aaxis1, names(aaxis1), "res")
aaxis1[, logres := log10(res)]

# sampled area
alab2 <- c(expression(paste(NULL<="1 m"^2)), expression("10 m"^2), 
           expression("100 m"^2), expression("1000 m"^2), expression("1 ha"),
           expression("10 ha"), expression("100 ha"), expression("1000 ha"), 
           expression(paste(10^4 , " ha")), expression(paste(10^5 , " ha")), 
           expression(paste(10^6 , " ha")), expression(paste(10^7 , " ha")), 
           expression(paste(10^8 , " ha")), expression(paste(10^9 , " ha")), 
           expression(paste(10^10 , " ha")))

aaxis2 <- cbind.data.frame(
  c(0.1 / 10000, 10 / 10000, 1000 / 10000, 1, 10, 10^2, 10^3, 10^4, 10^5, 10^6,
    10^7, 10^8, 10^9, 10^10))
aaxis2 <- data.table(aaxis2)
setnames(aaxis2, names(aaxis2), "area")
aaxis2[, logarea := log10(area)]

```

### Perturbed set
```{r, eval = FALSE}
bootp_dt <- rbindlist(bootperturb)
resdat <- data.table(x = log10(bootp_dt$t_btwn_samp), 
                      y = log10(bootp_dt$plot_res))
resdat$n <- rep(1, nrow(resdat))
rx <- range(resdat$x)
rx <- round(rx / 0.5) * 0.5  # round to nearest 0.5
# rx[1] <- -5
rx[2] <- 6.56
resdat[x < rx[1], x := rx[1]]
resdat[x > rx[2], x := rx[2]]
# rx[2] <- 7.6
ry <- range(aaxis1$logres)
ry[1] <- -5  # set limits to 0.01 cm^2
resdat[y < ry[1], y := ry[1]]
resdat[y > ry[2], y := ry[2]]
coordinates(resdat) <- ~x + y

# extent
extdat <- data.table(x = log10(bootp_dt$study_duration), 
                     y = log10(bootp_dt$sampled_area))
extdat$n <- rep(1, nrow(extdat))
ex <- range(taxis2$logdays)
ex <- c(floor(ex[1]), 5.56)#ceiling(ex[2]))
extdat[x < ex[1], x := ex[1]]
extdat[x > ex[2], x := ex[2]]
# ex <- round(ex / 0.5) * 0.5  # round to nearest 0.5
# ex[2] <- 7.6
ey <- range(aaxis2$logarea)
extdat[y < ey[1], y := ey[1]]
extdat[y > ey[2], y := ey[2]]
coordinates(extdat) <- ~x + y

# densities
# resolution
rres <- kdensity(rx[1], rx[2], ry[1], ry[2], 0.1, resdat, 1)
rres <- (rres / cellStats(rres, sum)) * 100
rng <- range(rres[is.finite(rres)])
rng[2] <- 0.1
bwidth <- (rng[2] - rng[1]) / 30
brks <- seq(rng[1], rng[2], bwidth)
brklabs <- seq(0, 0.1, 0.02)#round(brks[seq(1, length(brks), 5)], 2)

# extent
rext <- kdensity(ex[1], ex[2], ey[1], ey[2], 0.1, extdat, 1)
rext <- (rext / cellStats(rext, sum)) * 100
rng <- range(rext[is.finite(rext)])
rng[2] <- 0.1
bwidth <- (rng[2] - rng[1]) / 30
brks2 <- seq(rng[1], rng[2], bwidth)
brklabs2 <- round(brks2[seq(1, length(brks2), 6)], 2)

# cols <- colorRampPalette(c("blue", "gold", "red"))
# cols <- c(rev(terrain.colors(30))[1], cols(29))

cxa = 0.7
pdf("paper/figures/res_v_extent_pbstrap.pdf", width = 7, 
    height = 2.5)
par(mfrow = c(1, 2), mar = c(4, 4, 0.3, 3), oma = c(0, 0, 0, 1), 
    mgp = c(2, 0.5, 0))
# image(rres, col = cols, breaks = brks,
image(rres, col = rev(terrain.colors(30)), breaks = brks,
     axes = FALSE, xlab = "", ylab = "")
# plot(rres2, col = rev(terrain.colors(20)))
axis(1, at = taxis1$logdays[-c(5, 9, 10)], labels = tlab1[-c(5, 9, 10)], 
     las = 2, tcl = -0.2, cex.axis = cxa)
axis(2, at = aaxis1$logres[-1], labels = alab1[-1], las = 2, tcl = -0.2, 
     cex.axis = cxa)
# plot(rres2, axes = FALSE, legend.only = TRUE)
aargs <- list(mgp = c(3, 0.25, 0), at = brklabs, labels = brklabs, 
              cex.axis = cxa, tcl = -0.1)
plot(rres, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks, col = rev(terrain.colors(30)))
image(rext, col = rev(terrain.colors(30)), axes = FALSE, xlab = "", 
      ylab = "", breaks = brks2)
axis(1, at = taxis2$logdays[-5], labels = tlab2[-5], las = 2,
     cex.axis = cxa, tcl = -0.2)
axis(2, at = aaxis2$logarea, labels = alab2[-2], las = 2, cex.axis = cxa,
     tcl = -0.2)
aargs <- list(mgp = c(3, 0.25, 0), at = brklabs2, labels = brklabs2, 
              cex.axis = cxa, tcl = -0.1)
plot(rext, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks2, col = rev(terrain.colors(30)))
dev.off()

```

### Bootstrap
```{r, eval = FALSE}
bootdt <- rbindlist(bootsamp)
resdat2 <- data.table(x = log10(bootdt$t_btwn_samp), y = log10(bootdt$plot_res))
resdat2$n <- rep(1, nrow(resdat2))
rx <- range(resdat2$x)
rx <- round(rx / 0.5) * 0.5  # round to nearest 0.5
rx[2] <- 6.56
resdat2[x < rx[1], x := rx[1]]
resdat2[x > rx[2], x := rx[2]]
ry <- range(aaxis1$logres)
ry[1] <- -5  # set limits to 0.01 cm^2
resdat2[y < ry[1], y := ry[1]]
resdat2[y > ry[2], y := ry[2]]
coordinates(resdat2) <- ~x + y

# extent
extdat2 <- data.table(x = log10(bootdt$study_duration), 
                      y = log10(bootdt$sampled_area))
extdat2$n <- rep(1, nrow(extdat2))
ex <- range(taxis2$logdays)
ex <- c(floor(ex[1]), 5.56)#ceiling(ex[2]))
extdat2[x < ex[1], x := ex[1]]
extdat2[x > ex[2], x := ex[2]]
ey <- range(aaxis2$logarea)
extdat2[y < ey[1], y := ey[1]]
extdat2[y > ey[2], y := ey[2]]
coordinates(extdat2) <- ~x + y

# densities
# resolution
rres2 <- kdensity(rx[1], rx[2], ry[1], ry[2], 0.1, resdat2, 1)
rres2 <- (rres2 / cellStats(rres2, sum)) * 100
rng <- range(rres2[is.finite(rres2)])
bwidth <- (rng[2] - rng[1]) / 30
brks <- seq(rng[1], rng[2], bwidth)
brklabs <- seq(0, 0.1, 0.02)#round(brks[seq(1, length(brks), 5)], 2)

# extent
rext2 <- kdensity(ex[1], ex[2], ey[1], ey[2], 0.1, extdat2, 1)
rext2 <- (rext2 / cellStats(rext2, sum)) * 100
rng <- range(rext2[is.finite(rext2)])
rng[2] <- 0.1
bwidth <- (rng[2] - rng[1]) / 30
brks2 <- seq(rng[1], rng[2], bwidth)
brklabs2 <- brklabs #round(brks2[seq(1, length(brks2), 3)], 2)

cxa = 0.7
pdf("paper/figures/res_v_extent_bstrap.pdf", width = 7, 
    height = 2.5)
par(mfrow = c(1, 2), mar = c(4, 4, 0.3, 3), oma = c(0, 0, 0, 1), 
    mgp = c(2, 0.5, 0))
# image(rres, col = cols, breaks = brks,
image(rres2, col = rev(terrain.colors(30)), breaks = brks,
     axes = FALSE, xlab = "", ylab = "")
# plot(rres2, col = rev(terrain.colors(20)))
axis(1, at = taxis1$logdays[-c(5, 9, 10)], labels = tlab1[-c(5, 9, 10)], 
     las = 2, tcl = -0.2, cex.axis = cxa)
axis(2, at = aaxis1$logres[-1], labels = alab1[-1], las = 2, tcl = -0.2, 
     cex.axis = cxa)
# plot(rres2, axes = FALSE, legend.only = TRUE)
aargs <- list(mgp = c(3, 0.25, 0), at = brklabs, labels = brklabs, 
              cex.axis = cxa, tcl = -0.1)
plot(rres2, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks, col = rev(terrain.colors(30)))

image(rext2, col = rev(terrain.colors(30)), axes = FALSE, xlab = "", 
      ylab = "", breaks = brks2)
axis(1, at = taxis2$logdays[-5], labels = tlab2[-5], las = 2,
     cex.axis = cxa, tcl = -0.2)
axis(2, at = aaxis2$logarea, labels = alab2[-2], las = 2, cex.axis = cxa,
     tcl = -0.2)
aargs <- list(mgp = c(3, 0.25, 0), at = brklabs2, labels = brklabs2, 
              cex.axis = cxa, tcl = -0.1)
plot(rext2, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks2, col = rev(terrain.colors(30)))
dev.off()

# datf[, plot(log10(study_duration), log10(sampled_area), xlim)]

```

### Primary dataset (main figure)
```{r, eval = FALSE}
resdat3 <- data.table(x = log10(to_infin_byond(datf$t_btwn_samp)), 
                      y = log10(datf$plot_res))
resdat3$n <- rep(1, nrow(resdat3))
rx <- range(resdat3$x)
rx <- round(rx / 0.5) * 0.5  # round to nearest 0.5
rx[2] <- 6.56
resdat3[x < rx[1], x := rx[1]]
resdat3[x > rx[2], x := rx[2]]
ry <- range(aaxis1$logres)
ry[1] <- -5  # set limits to 0.01 cm^2
resdat3[y < ry[1], y := ry[1]]
resdat3[y > ry[2], y := ry[2]]
coordinates(resdat3) <- ~x + y

# extent
extdat3 <- data.table(x = log10(datf$study_duration), 
                      y = log10(datf$sampled_area))
extdat3$n <- rep(1, nrow(extdat3))
ex <- range(taxis2$logdays)
ex <- c(floor(ex[1]), 5.56)#ceiling(ex[2]))
extdat3[x < ex[1], x := ex[1]]
extdat3[x > ex[2], x := ex[2]]
ey <- range(aaxis2$logarea)
extdat3[y < ey[1], y := ey[1]]
extdat3[y > ey[2], y := ey[2]]
coordinates(extdat3) <- ~x + y

# temporal framing
tempdat <- data.table(x = log10(to_infin_byond(datf$t_btwn_samp)), 
                      y = log10(datf$study_duration))
tempdat$n <- rep(1, nrow(tempdat))
tx <- range(tempdat$x)
tx <- round(rx / 0.5) * 0.5  # round to nearest 0.5
tx[2] <- 6.56
tempdat[x < rx[1], x := rx[1]]
tempdat[x > rx[2], x := rx[2]]
ty <- range(taxis2$logdays)
ty <- c(floor(ty[1]), 5.56)#ceiling(ex[2]))
tempdat[y < ty[1], y := ty[1]]
tempdat[y > ty[2], y := ty[2]]
coordinates(tempdat) <- ~x + y

# spatial framing
spatdat <- data.table(x = log10(datf$plot_res), y = log10(datf$sampled_area))
spatdat$n <- rep(1, nrow(spatdat))
sx <- range(aaxis1$logres)
sx[1] <- -5  # set limits to 0.01 cm^2
spatdat[x < sx[1], y := sx[1]]
spatdat[x > sx[2], y := sx[2]]
sy <- range(aaxis2$logarea)
spatdat[y < sy[1], y := sy[1]]
spatdat[y > sy[2], y := sy[2]]
coordinates(spatdat) <- ~x + y

# densities
# resolution
rres3 <- kdensity(rx[1], rx[2], ry[1], ry[2], 0.1, resdat3, 1)
rres3 <- (rres3 / cellStats(rres3, sum)) * 100
rng <- range(rres3[is.finite(rres3)])
bwidth <- (rng[2] - rng[1]) / 30
brks <- seq(rng[1], rng[2], bwidth)
brklabs <- seq(0, 0.1, 0.02)#round(brks[seq(1, length(brks), 5)], 2)

# extent
rext3 <- kdensity(ex[1], ex[2], ey[1], ey[2], 0.1, extdat3, 1)
rext3 <- (rext3 / cellStats(rext3, sum)) * 100
rng <- range(rext3[is.finite(rext3)])
rng[2] <- 0.1
bwidth <- (rng[2] - rng[1]) / 30
brks2 <- seq(rng[1], rng[2], bwidth)
brklabs2 <- brklabs #round(brks2[seq(1, length(brks2), 3)], 2)

# # temporal
# tres <- kdensity(tx[1], tx[2], ty[1], ty[2], 0.1, tempdat, 1)
# #spatial
# sres <- kdensity(sx[1], sx[2], sy[1], sy[2], 0.1, spatdat, 1)
# image(sres, col = rev(terrain.colors(30)))



cxa = 0.7
pdf("paper/figures/res_v_extent.pdf", width = 7, 
    height = 2.5)
par(mfrow = c(1, 2), mar = c(4, 4, 0.3, 3), oma = c(0, 0, 0, 1), 
    mgp = c(2, 0.5, 0))
image(rres3, col = rev(terrain.colors(30)), breaks = brks,
     axes = FALSE, xlab = "", ylab = "")
axis(1, at = taxis1$logdays[-c(5, 9, 10)], labels = tlab1[-c(5, 9, 10)], 
     las = 2, tcl = -0.2, cex.axis = cxa)
axis(2, at = aaxis1$logres[-1], labels = alab1[-1], las = 2, tcl = -0.2, 
     cex.axis = cxa)
mtext("Sampling interval", 1, cex = cxa, line = 3)
mtext("Spatial resolution", 2, cex = cxa, line = 3)

aargs <- list(mgp = c(3, 0.25, 0), at = brklabs, labels = brklabs, 
              cex.axis = cxa, tcl = -0.1)
plot(rres3, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks, col = rev(terrain.colors(30)))

image(rext3, col = rev(terrain.colors(30)), axes = FALSE, xlab = "", 
      ylab = "", breaks = brks2)
axis(1, at = taxis2$logdays[-5], labels = tlab2[-5], las = 2,
     cex.axis = cxa, tcl = -0.2)
axis(2, at = aaxis2$logarea, labels = alab2[-2], las = 2, cex.axis = cxa,
     tcl = -0.2)
aargs <- list(mgp = c(3, 0.25, 0), at = brklabs2, labels = brklabs2, 
              cex.axis = cxa, tcl = -0.1)
mtext("Temporal duration", 1, cex = cxa, line = 3)
mtext("Spatial extent", 2, cex = cxa, line = 3)

plot(rext3, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, breaks = brks2, col = rev(terrain.colors(30)))
dev.off()

# datf[, plot(log10(study_duration), log10(sampled_area), xlim)]


```

## Ancillary/supplementary plots and stats

### Statistics
```{r, eval=FALSE}
length(which(dat$study_type %in% 
               c("remote sensing", "other geographic data"))) / nrow(dat)
dat[t_btwn_samp == 0, .N] / dat[, .N]  # 31% of samples are once-offs
dat[study_duration == samp_duration, .N]


par(mfrow = c(2, 2))
datf[, {
  hist(log10(plot_res), main = "Plot res")
  hist(log10(t_btwn_samp), main = "Interval")
  hist(log10(sampled_area), main = "Area")
  hist(log10(study_duration), main = "Duration")
}]

```

### Sensitivity
Just for the four main variables. Rules: 

+ If `plot_res` and/or `n_sites` uncertain, then `sampled_area` must be. Recalculate using random draw within the uncertain variable 
+ If `t_btwn_samp` and/or `samp_duration` uncertain, do the same as above, but we have no variable for n repeats for calculating `study_duration`.

```{r}
svars <- c("plot_res", "n_sites", "sampled_area", "samp_duration",
           "t_btwn_samp", "study_duration")

sens <- gsub("\\\\", ";", dat$sensitivity)
sens <- gsub(", ", ";", gsub("; ", ";", sens))
sens <- tolower(sens)
sensl <- strsplit(sens, ";")
# unique(unlist(sensl))

sens2 <- gsub("plo_", "plot_", sens)  # fix this one
sens2 <- gsub("[[:blank:]]", "_", sens2)  # replace spaces with _

corrtab <- cbind(c("^res", "plo_res", "sample_area", "samples_area", 
                   "sampled area",
                   "t_btwn_samples", "t_btwn_sample", "t_btwn_samp_samp", 
                   "t_twn_samp", "t_btw_samp", "samp_duratiion", 
                   "sampling_duration", "sample_duration", 
                   "plot_resolution", "number_of_sites", 
                   "time_between_sampling", "plot_size", 
                   "time_between_samples", "samp_study", ":", " ", ";_"), 
                 c(svars[c(1, 1, 3, 3, 3, 5, 5, 5, 5, 5, 4, 4, 4, 1, 2,
                           5, 1, 5)], "samp;study", ";", ";", ";"))

for(i in 1:nrow(corrtab)) {
  sens2 <- gsub(corrtab[i, 1], corrtab[i, 2], sens2)
}
# gsub("[a-z]( )[a-z]", "_", sens[[228]])
# sens[[228]]
# sens2[is.na(sens2)]
sens2[is.na(sens2)] <- "none"
sensl2 <- lapply(1:length(sens2), function(x) strsplit(sens2[x], ";")[[1]])
# unique(unlist(sensl))
# unique(unlist(sensl2))

# create a sensitivity table
senst <- do.call(cbind.data.frame, lapply(svars, function(x) {
  v <- sapply(sensl2, function(y) ifelse(any(y == x), 1, 0))
  # ifelse(is.na(v), 0, v)
}))
colnames(senst) <- c("res", "n", "sarea", "sampd", "tbtwn", "studyd")

# add column for uncertainty about n repeats
# senst$nrep <- rep(0, nrow(senst))

# i <- 300:305
# sensl2[i]
# senst[i, ]

# apply fixes (mostly to account for observer omissions)

# 1. if samp_duration OR t_btwn_samp is uncertain, study_duration must also be. 
id <- which((senst$sampd == 1 | senst$tbtwn == 1) & senst$studyd == 0)
senst[id, "studyd"] <- 1 

# 2. if study_duration is uncertain but t_btwn and samp_duration are not, treat
# both as uncertain
# although it is possible that just n_repeats is uncertain, but more likely 
# that observers didn't note this is sensitive. 
id <- which(senst$tbtwn == 0 & senst$sampd == 0 & senst$studyd == 1)
senst[id, c("sampd", "tbtwn")] <- 1

# 3. if plot_res or n_sites is uncertain, then sampled_area must be
id <- which((senst$res == 1 | senst$n == 1) & senst$sarea == 0)
senst[id, "sarea"] <- 1

# percentage of records that are uncertain
round(colSums(senst) / nrow(senst) * 100, 1)

```

### Varying kernel sizes
```{r,eval = FALSE}
# resolution data
# resdat <- data.table(x = log10(datf$t_btwn_samp), y = log10(datf$plot_res))
# resdat$n <- rep(1, nrow(resdat))
# coordinates(resdat) <- ~x + y
# rx <- range(resdat$x)
# # rx <- range(aaxis$logarea)
# rx <- round(rx / 0.5) * 0.5  # round to nearest 0.5
# # rx[1] <- -6.5  # set temporal interval to -6.5 to have null returns centered
# # ry <- range(resdat$y)
# ry <- range(aaxis$logarea)
# ry <- round(ry / 0.5) * 0.5  # round to nearest 0.5
# 
# # extent data
# # fix area rounded to zero in Jon's plots
# extdat <- data.table("x" = log10(dat$study_duration), 
#                      "y" = log10(dat$sampled_area)) 
# # extdat[is.infinite(x), ]; extdat[is.infinite(y), ]
# 
# extdat$n <- rep(1, nrow(extdat))
# coordinates(extdat) <- ~x + y
# # ex <- range(extdat$x)
# ex <- range(taxis2$logdays)
# ex <- round(ex / 0.5) * 0.5  # round to nearest 0.5
# # ex[1] <- -5
# ey <- range(extdat$y)
# ey <- round(ey / 0.5) * 0.5  # round to nearest 0.5

# density rasters
# vary the kernel size about them
kernsl <- lapply(c(0.4, 0.6, 0.8, 1), function(x) {
  rr <- kdensity(rx[1], rx[2], ry[1], ry[2], 0.1, resdat3, x)
  rr <- (rr / cellStats(rr, sum)) * 100
  er <- kdensity(ex[1], ex[2], ey[1], ey[2], 0.1, extdat3, x)
  er <- (er / cellStats(er, sum)) * 100
  kerns <- list("res" = rr, "ext" = er)
})

# As separate plots
pdf("paper/figures/res_v_extent_ksize.pdf", width = 7, height = 12, )
par(mfrow = c(4, 2), oma = c(2, 2, 0, 0), mar = c(4, 4, 4, 4))
lapply(kernsl, function(x) {
  # x <- kernsl[[1]]
  image(x$res, col = rev(terrain.colors(30)), axes = FALSE, xlab = "", 
        ylab = "")#, ylim = range(aaxis1$logarea))
  axis(1, at = taxis1$logdays[-c(5, 9, 10)], labels = tlab1[-c(5, 9, 10)], 
       las = 2, tcl = -0.2, cex.axis = cxa)
  axis(2, at = aaxis1$logres[-1], labels = alab1[-1], las = 2, tcl = -0.2, 
       cex.axis = cxa)  
  aargs <- list(mgp = c(3, 0.25, 0), #at = brklabs, labels = brklabs, 
                cex.axis = cxa, tcl = -0.1)
  plot(x$res, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
     legend.shrink = 0.9, #breaks = brks, 
     col = rev(terrain.colors(30)))
  
  image(x$ext, col = rev(terrain.colors(30)), axes = FALSE, xlab = "", 
        ylab = "")
  axis(1, at = taxis2$logdays[-5], labels = taxis2$label[-5], las = 2,
       cex.axis = cxa, tcl = -0.2)
  axis(2, at = aaxis2$logarea, labels = alab2[-2], las = 2, cex.axis = cxa,
       tcl = -0.2)
  aargs <- list(mgp = c(3, 0.25, 0), #at = brklabs2, labels = brklabs2, 
                cex.axis = cxa, tcl = -0.1)
  plot(x$ext, legend.only = TRUE, axis.args = aargs, legend.width = 1.25,
       legend.shrink = 0.9, #breaks = brks2, 
       col = rev(terrain.colors(30)))
})
par(xpd = NA)
xx <- grconvertX(0.5, from = "ndc", to = "inches")
ii <- c(0.4, 0.6, 0.8, 1)
yy <- c(0.95, 0.75, 0.5, 0.25)
# yy <- c(-1, -5, -10, -20)
for(i in 1:length(ii)) {
  y <- grconvertY(yy[i], from = "ndc", to = "inches")
  # text(x = xx, y = y, labels = paste("kernel =", ii[i]))
  # par(xpd = NA)
  # mtext(text = paste("kernel =", ii[i]), side = 3, line = yy[i])
}
dev.off()

# plot(rrs, xlim = c(-5, 15), ylim = c(-5, 15), 
#      xlab = "Sample interval - log10(days)", 
#      ylab = "Plot resolution - log10(m^2)")
# plot(ers, box = FALSE, xlim = c(-5, 15), ylim = c(-5, 15), 
#      xlab = "Study duration - log10(days)", ylab = "Sampled area - log10(ha)")
# dev.off()
```
